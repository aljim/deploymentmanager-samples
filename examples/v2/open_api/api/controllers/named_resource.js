'use strict';
/**
 * 'use strict' is not required but helpful for turning syntactical errors into
 * true errors in the program flow
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode
 */

/**
 * Modules make it possible to import JavaScript files into your application.
 * Modules are imported
 * using 'require' statements that give you a reference to the module.
 *
 *  It is a good idea to list the modules that your application depends on in
 * the package.json in the project root
 */
var util = require('util');
var namedResources = {};
var restify = require('restify');
var uuid = require('node-uuid');
var db = process.env.DB == 'DATASTORE' ? require('./datastore-db.js') :
                                         require('./local-db.js');

/**
 * Once you 'require' a module you can reference the things that it exports.
 * These are defined in module.exports.
 *
 * For a controller in a127 (which this is) you should export the functions
 * referenced in your Swagger document by name.
 *
 * Either:
 *  - The HTTP Verb of the corresponding operation (get, put, post, delete, etc)
 *  - Or the operationId associated with the operation in your Swagger document
 *
 *  In the starter/skeleton project the 'get' operation on the '/hello' path has
 * an operationId named 'hello'.  Here,
 *  we specify that in the exports of this module that 'hello' maps to the
 * function named 'hello'
 */
module.exports = {
  getNamedResource: getNamedResource,
  createNamedResource: createNamedResource,
  updateNamedResource: updateNamedResource,
  deleteNamedResource: deleteNamedResource,
  getServerNamedResource: getNamedResource,
  createServerNamedResource: createServerNamedResource,
  updateServerNamedResource: updateNamedResource,
  deleteServerNamedResource: deleteNamedResource,
  getBodyNamedResource: getNamedResource,
  createBodyNamedResource: createBodyNamedResource,
  updateBodyNamedResource: updateNamedResource,
  deleteBodyNamedResource: deleteNamedResource
};

/**
 * Generates an UUID depending on timestamp.
 * @return {string} A changing fingerprint to lock concurrent updates.
 */
function fingerprint() {
  return uuid.v1();
}

/**
 * Saves the resource using LevelDB key-value store.
 * @param {object} resource The REST resource to be saved.
 * @param {object} res Restify response to return to the user.
 * @param {object} next Restify handler object for errors.
 */
function saveResource(resource, res, next) {
  db.put(resource.name, resource, function(err) {
    if (err) {
      if (err.notFound) {
        next(new restify.NotFoundError(name + ' is not found'));
      } else {
        console.error(err);
        next(new restify.InternalServerError());
      }
      return;
    }
    res.json(resource);
  });
}

/**
 * Gets the resource using LevelDB key-value store, returns 404 if not found.
 * @param {string} name The name of the resource to be returned.
 * @param {object} res Restify response to return to the user.
 * @param {object} next Restify handler object for errors.
 * @param {Function} cb callback with the content of the get.
 */
function getResource(name, res, next, cb) {
  db.get(name, function(err, value) {
    if (err) {
      if (err.notFound) {
        next(new restify.NotFoundError(name + ' is not found'));
      } else {
        console.log(err);
        next(new restify.InternalServerError());
      }
      return;
    }
    cb(value);
  });
}

/**
 * It gets the resource and fails with 404 if not found, 500 otherwise
 * @param {object} req Restify request from the user.
 * @param {object} res Restify response to return to the user.
 * @param {object} next Restify handler object for errors.
 */
function getNamedResource(req, res, next) {
  // variables defined in the Swagger document can be referenced using
  // req.swagger.params.{parameter_name}
  var name = req.swagger.params.resourceName.value;
  getResource(name, res, next, function(value) {
    res.json(value);
  });
}

/**
 * Creates a resource, and name is generated by the server as a UUID
 * @param {object} req Restify request from the user.
 * @param {object} res Restify response to return to the user.
 * @param {object} next Restify handler object for errors.
 */
function createServerNamedResource(req, res, next) {
  createResource(req, res, next, 'server-' + uuid.v1());
}

/**
 * Creates a resource, name comes in the body
 * @param {object} req Restify request from the user.
 * @param {object} res Restify response to return to the user.
 * @param {object} next Restify handler object for errors.
 */
function createBodyNamedResource(req, res, next) {
  createResource(req, res, next, req.body.name);
}

/**
 * Creates a resource, name comes in the path
 * @param {object} req Restify request from the user.
 * @param {object} res Restify response to return to the user.
 * @param {object} next Restify handler object for errors.
 */
function createNamedResource(req, res, next) {
  createResource(req, res, next, req.swagger.params.resourceName.value);
}

/**
 * Common create, it saves it on database, and fails with 409 if resource
 * already exists.
 * @param {object} req Restify request from the user.
 * @param {object} res Restify response to return to the user.
 * @param {object} next Restify handler object for errors.
 * @param {string} name The name of the resource to be created.
 */
function createResource(req, res, next, name) {
  // variables defined in the Swagger document can be referenced using
  // req.swagger.params.{parameter_name}
  db.get(name, function(err, value) {
    if (err) {
      if (err.notFound) {
        var value = req.body;
        value.name = name;
        value.fingerprint = fingerprint();
        saveResource(value, res, next);
      } else {
        console.error(err);
        next(new restify.InternalServerError());
      }
      return;
    }
    next(new restify.ConflictError(name + ' already exists'));
  });
}

/**
 * Delete resource by name.
 * @param {object} req Restify request from the user.
 * @param {object} res Restify response to return to the user.
 * @param {object} next Restify handler object for errors.
 */
function deleteNamedResource(req, res, next) {
  // variables defined in the Swagger document can be referenced using
  // req.swagger.params.{parameter_name}
  var name = req.swagger.params.resourceName.value;
  getResource(name, res, next, function(value) {
    db.del(name, function(err, value) {
      if (err) {
        if (err.notFound) {
          next(new restify.NotFoundError(name + ' is not found'));
        } else {
          console.error(err);
          next(new restify.InternalServerError());
        }
        return;
      }
      res.json(value);
    });
  });
}

/**
 * Update resource with name provided
 * @param {object} req Restify request from the user.
 * @param {object} res Restify response to return to the user.
 * @param {object} next Restify handler object for errors.
 */
function updateNamedResource(req, res, next) {
  // variables defined in the Swagger document can be referenced using
  // req.swagger.params.{parameter_name}
  var name = req.swagger.params.resourceName.value;
  getResource(name, res, next, function(value) {
    var body = req.body;
    if (value.fingerprint !== body.fingerprint) {
      next(new restify.PreconditionFailedError(
          'Fingerprint does not match, expected [' + value.fingerprint + ']' +
          ' received [' + body.fingerprint + ']'));
      return;
    }
    value.message = body.message;
    value.fingerprint = fingerprint();
    saveResource(value, res, next);
  });
}
